# -*- coding: utf-8 -*-
"""Geom algs

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R5FTJX04DLFEVtNiaGhZ6wcLGE7dqmZA
"""

#line Intersection
p1 = [10,0]
q1 = [0,10]
p2 = [0,0]
q2 = [10,10]


def orientation(y1, y2, y3, x1, x2, x3):
  k = (y2 - y1)*(x3 - x2) - (y3 - y2)*(x2 - x1)

  if k > 0:
    return 1

  if k < 0:
    return 2

  if k == 0 :
    return 0

o1 = orientation(p1[1], q1[1], p2[1],p1[0],q1[0],p2[0])
o2 = orientation(p1[1], q1[1], q2[1],p1[0],q1[0],q2[0])
o3 = orientation(p2[1], q2[1], p1[1],p2[0],q2[0],p1[0])
o4 = orientation(p2[1], q2[1], q1[1],p2[0],q2[0],q1[0])


if ((o1 != o2) and (o3 != o4)):
  print(True)
else:
  print(False)

# line intersect
def orientation(p, q, r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
    if val == 0:
        return 0
    elif val > 0:
        return 1
    else:
        return 2

def do_intersect(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)

    if o1 != o2 and o3 != o4:
        return True


    def on_segment(p, q, r):
        return min(p[0], q[0]) <= r[0] <= max(p[0], q[0]) and min(p[1], q[1]) <= r[1] <= max(p[1], q[1])

    if o1 == 0 and on_segment(p1, q1, p2): return True
    if o2 == 0 and on_segment(p1, q1, q2): return True
    if o3 == 0 and on_segment(p2, q2, p1): return True
    if o4 == 0 and on_segment(p2, q2, q1): return True

    return False

p1, q1 = (1, 1), (10, 1)
p2, q2 = (1, 2), (10, 2)
print("Do the segments intersect?", do_intersect(p1, q1, p2, q2))









# Line Intersection
# Function to check if two line segments intersect

def orientation(p, q, r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
    if val == 0: return 0
    return 1 if val > 0 else 2

def on_segment(p, q, r):
    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1])

def do_intersect(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)

    if o1 != o2 and o3 != o4:
        return True
    if o1 == 0 and on_segment(p1, p2, q1): return True
    if o2 == 0 and on_segment(p1, q2, q1): return True
    if o3 == 0 and on_segment(p2, p1, q2): return True
    if o4 == 0 and on_segment(p2, q1, q2): return True
    return False

# Graham Scan for Convex Hull

def graham_scan(points):
    points = sorted(points, key=lambda p: (p[0], p[1]))

    def cross(o, a, b):
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

    lower = []
    for p in points:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)

    upper = []
    for p in reversed(points):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)

    return lower[:-1] + upper[:-1]

# Jarvis March for Convex Hull

def jarvis_march(points):
    n = len(points)
    if n < 3:
        return points

    hull = []
    leftmost = min(points, key=lambda p: p[0])
    p = leftmost

    while True:
        hull.append(p)
        q = points[0]
        for r in points:
            if (q == p) or (orientation(p, q, r) == 2):
                q = r
        p = q
        if p == leftmost:
            break

    return hull

